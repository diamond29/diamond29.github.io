<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Treasure hunter</title>
</head>
<body>
<script src="./pixi/pixi.min.js"></script>
<script>

//Aliases
const Application = PIXI.Application,
    Container = PIXI.Container,
    loader = PIXI.Loader.shared,
    resources = PIXI.Loader.shared.resources,
    Graphics = PIXI.Graphics,
    TextureCache = PIXI.utils.TextureCache,
    Sprite = PIXI.Sprite,
    Text = PIXI.Text,
    TextStyle = PIXI.TextStyle;

//Create a Pixi Application
const app = new Application({ 
    width: 512, 
    height: 512,                       
    antialias: true, 
    transparent: false, 
    resolution: 1
  }
);

//Add the canvas that Pixi automatically created for you to the HTML document
document.body.appendChild(app.view);

loader
  .add("./examples/images/treasureHunter.json")
  .load(setup);

//Define variables that might be used in more 
//than one function
let state, explorer, treasure, blobs, chimes, exit, player, dungeon,
    door, healthBar, message, gameScene, gameOverScene, enemies, id, moveSpacesContainer, currentMoveSpacesContainer;

function drawGrid(gameScene, gridHeight, gridWidth) {
  xWidth = gameScene.width / gridWidth
  yWidth = gameScene.height / gridHeight

  for (let i = 1; i < gridWidth; i++) {
    line = new Graphics()
    line.lineStyle({width: 2, color: 0x000000, alpha: 1});
    line.moveTo(0, 0);
    line.lineTo(0, gameScene.height);

    line.x = i * xWidth
    gameScene.addChild(line)
  }

  for (let i = 1; i < gridHeight; i++) {
    line = new Graphics()
    line.lineStyle({width: 2, color: 0x000000, alpha: 1});
    line.moveTo(0, 0);
    line.lineTo(gameScene.width, 0);

    line.y = i * yWidth
    gameScene.addChild(line)
  }
}

let xWidth = 0
let yWidth = 0
let grid = []
let gridWidth = 16,
  gridHeight = 16;

function gridPositionFromPoint(x, y) {
  return { x: Math.floor(x / xWidth), y: Math.floor(y / yWidth) }
}

function setup() {

  //Make the game scene and add it to the stage
  gameScene = new Container();
  app.stage.addChild(gameScene);
  gameScene.interactive = true
  gameScene.on("click", (event) => {
    ({ x, y } = gridPositionFromPoint(event.data.global.x, event.data.global.y))

    if (explorer.isMoving === false && (Math.abs(explorer.xIndex - x) + Math.abs(explorer.yIndex - y)) <= 2) {
      explorer.newXIndex = x
      explorer.newYIndex = y
      explorer.isMoving = true
    }
  })

  grid = [...Array(gridWidth)].map(e => Array(gridHeight));

  //Create an alias for the texture atlas frame ids
  id = resources["./examples/images/treasureHunter.json"].textures;

  //Dungeon
  dungeon = new Sprite(id["dungeon.png"]);
  moveSpacesContainer = new Container()
  dungeon.addChild(moveSpacesContainer)

  gameScene.addChild(dungeon);

  if (true) {
    drawGrid(gameScene, gridWidth, gridHeight)
  }

  //Door
  door = new Sprite(id["door.png"]); 
  door.position.set(32, 0);
  gameScene.addChild(door);

  //Explorer
  explorer = new Sprite(id["explorer.png"]);

  explorer.xIndex = 2
  explorer.yIndex = 2
  explorer.isMoving = false
  gameScene.addChild(explorer);
  
  //Treasure
  treasure = new Sprite(id["treasure.png"]);
  treasure.x = gameScene.width - treasure.width - 48;
  treasure.y = gameScene.height / 2 - treasure.height / 2;
  gameScene.addChild(treasure);

  //Make the blobs
  let numberOfBlobs = 6,
      spacing = 48,
      xOffset = 150;
  
  //An array to store all the blob monsters
  blobs = [];

  //Make as many blobs as there are `numberOfBlobs`
  for (let i = 0; i < numberOfBlobs; i++) {

    //Make a blob
    const blob = new Sprite(id["covid.png"]);

    const yIndex = randomInt(4, 16);
    const xIndex = randomInt(4, 16);

    blob.x = xIndex * xWidth;
    blob.y = yIndex * yWidth;
    
    blob.width = xWidth
    blob.height = yWidth

    //Push the blob into the `blobs` array
    blobs.push(blob);

    //Add the blob to the `gameScene`
    gameScene.addChild(blob);
  }

  //Create the health bar
  healthBar = new Container();
  healthBar.position.set(app.stage.width - 170, 4)
  gameScene.addChild(healthBar);

  //Create the black background rectangle
  const innerBar = new Graphics();
  innerBar.beginFill(0x000000);
  innerBar.drawRect(0, 0, 128, 8);
  innerBar.endFill();
  healthBar.addChild(innerBar);

  //Create the `gameOver` scene
  gameOverScene = new Container();
  app.stage.addChild(gameOverScene);

  //Make the `gameOver` scene invisible when the game first starts
  gameOverScene.visible = false;

  //Create the text sprite and add it to the `gameOver` scene
  const style = new TextStyle({
    fontFamily: "Futura",
    fontSize: 64,
    fill: "white"
  });
  message = new Text("The End!", style);
  message.x = 120;
  message.y = app.stage.height / 2 - 32;
  gameOverScene.addChild(message);

  //Set the game state
  state = play;
 
  //Start the game loop 
  app.ticker.add((delta) => gameLoop(delta));
}


function gameLoop(delta) {

  //Update the current game state:
  state(delta);
}

maxSpeed = 2

function newPointFromCurrentAndDestination(currentPoint, destinationPoint, speed) {
  xDistance = destinationPoint.x - currentPoint.x
  yDistance = destinationPoint.y - currentPoint.y

  totalDistance = Math.sqrt(Math.pow(xDistance, 2) + Math.pow(yDistance, 2))

  if (totalDistance < speed) {
    return destinationPoint
  } else {
    ratio = speed / totalDistance

    return {x: currentPoint.x + xDistance * ratio, y: currentPoint.y + yDistance * ratio}
  }
}

function play(delta) {
  if (explorer.isMoving) {
    destinationX = xWidth * explorer.newXIndex + explorer.width / 4
    destinationY = yWidth * explorer.newYIndex
    destinationPoint = {x: destinationX, y: destinationY}
    currentPoint = {x: explorer.x, y: explorer.y}

    newPoint = newPointFromCurrentAndDestination(currentPoint, destinationPoint, 2)

    explorer.x = newPoint.x
    explorer.y = newPoint.y

    if (newPoint === destinationPoint) {
      explorer.isMoving = false
      explorer.xIndex = explorer.newXIndex
      explorer.yIndex = explorer.newYIndex
    }
    currentMoveSpacesContainer.visible = false
  } else {
    explorer.x = xWidth * explorer.xIndex + explorer.width / 4
    explorer.y = yWidth * explorer.yIndex
  }

  moveLimit = 2
  if (currentMoveSpacesContainer !== undefined
   && (currentMoveSpacesContainer.xIndex != explorer.xIndex
   || currentMoveSpacesContainer.yIndex != explorer.yIndex)) {
     console.log("removed movespaces")
    moveSpacesContainer.removeChild(currentMoveSpacesContainer)
    currentMoveSpacesContainer = undefined
  }

  if (currentMoveSpacesContainer === undefined && !explorer.isMoving) {
    currentMoveSpacesContainer = new Container()
  
    let moveSpaces = []
  
    for(let i = moveLimit * -1; i <= moveLimit; i++) {
      for(let j = (moveLimit - Math.abs(i)) * -1; j <= (moveLimit - Math.abs(i)); j++) {
        moveSpaces = [...moveSpaces, [i + explorer.xIndex, j + explorer.yIndex]]
      }
    }
  
    for (const spaceCoords of moveSpaces) {
      const space = new Graphics();
      space.beginFill(0x8B0000, 0.5);
      space.drawRect(0, 0, xWidth, yWidth);
      space.endFill();
  
      space.x = xWidth * spaceCoords[0]
      space.y = yWidth * spaceCoords[1]
  
      currentMoveSpacesContainer.addChild(space)
    }

    currentMoveSpacesContainer.xIndex = explorer.xIndex
    currentMoveSpacesContainer.yIndex = explorer.yIndex
  
    moveSpacesContainer.addChild(currentMoveSpacesContainer)
  }

}

function end() {
  gameScene.visible = false;
  gameOverScene.visible = true;
}

function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

//The `keyboard` helper function
function keyboard(keyCode) {
  const key = {};
  key.code = keyCode;
  key.isDown = false;
  key.isUp = true;
  key.press = undefined;
  key.release = undefined;
  //The `downHandler`
  key.downHandler = function(event) {
    if (event.keyCode === key.code) {
      if (key.isUp && key.press) {
        key.press();
      }
      key.isDown = true;
      key.isUp = false;
    }
    event.preventDefault();
  };

  //The `upHandler`
  key.upHandler = function(event) {
    if (event.keyCode === key.code) {
      if (key.isDown && key.release) {
        key.release();
      }
      key.isDown = false;
      key.isUp = true;
    }
    event.preventDefault();
  };

  //Attach event listeners
  window.addEventListener("keydown", key.downHandler.bind(key), false);
  window.addEventListener("keyup", key.upHandler.bind(key), false);
  return key;
}

</script>
</body>
</html>
